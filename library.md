# Library

## `bufio`

### `bufio.Scanner`

    type Scanner struct {
        // Has unexported fields
    }
        Scanner provides a convenient interface for reading data such as a file
        of newline-delimited lines of text. Successive calls to the Scan method
        will step through the 'tokens' of a file, skipping the bytes between
        the tokens. The specification of a token is defined by a split function
        of type SplitFunc; the default split function breaks the input into
        lines with line termination stripped. Split functions are defined in
        this package for scanning a file into lines, bytes, UTF-8-encoded
        runes, and space-delimited words. The client may instead provide a
        custom split function.

        Scanning stops unrecoverably at EOF, the first I/O error, or a token
        too large to fit in the buffer. When a scan stops, the reader may have
        advanced arbitrarily far past the last token. Programs that need more
        control over error handling or large tokens, or must run sequential
        scans on a reader, should use bufio.Reader instead.

Example:

    input := bufio.NewScanner(os.Stdin)

#### `bufio.Scanner.Scan`

    func (s *Scanner) Scan() bool
        Scan advances the Scanner to the next token, which will then be
        available through the Bytes or Text method. It returns false when the
        scan stops, either by reaching the end of the input or an error. After
        Scan returns false, the Err method will return any error that occurred
        during scanning, except that if it was io.EOF, Err will return nil.
        Scan panics if the split function returns too many empty tokens without
        advancing the input. This is a common error mode for scanners.

Example:

    input := bufio.NewScanner(os.Stdin)
    for input.Scan() {
        fmt.Println(input.Text())
    }

#### `bufio.Scanner.Text`

    func (s *Scanner) Text() string
        Text returns the most recent token generated by a call to Scan as a
        newly allocated string holding its bytes.

## `fmt`

### `fmt.Println`

    func Println(a ...interface{}) (n int, err error)
        Println formats using the default formats for its operands and writes
        to standard output. Spaces are always added between operands and a
        newline is appended. It returns the number of bytes written and any
        write error encountered.

Example:

    fmt.Println("This is a test.")

### `fmt.Printf`

    func Printf(format string, a ...interface{}) (n int, err error)
        Printf formats according to a format specifier and writes to standard
        output. It returns the number of bytes written and any write error
        encountered.

Example

    fmt.Printf("%d / %d = %f", 10, 3, 10/3.0) // 10 / 3 = 3.333333

## `os`

### `os.Args`

    var Args []string
        Args hold the command-line arguments, starting with the program name.

    for i, a := range os.Args[1:] {
        fmt.Printf("Argument %d is: %s\n", i, a)
    }

### `os.Stdin`, `os.Stdout` and `os.Stderr`

    var (
        Stdin  = NewFile(uintptr(syscall.Stdin), "/dev/stdin")
        Stdout = NewFile(uintptr(syscall.Stdout), "/dev/stdout")
        Stderr = NewFile(uintptr(syscall.Stderr), "/dev/stderr")
    )
        Stdin, Stdout, and Stderr are open Files pointing to the standard
        input, standard output, and standard error file descriptors.

        Note that the Go runtime writes to standard error for panics and
        crashes: closing Stderr may cause those messages to go elsewhere,
        perhapts to a file opened later.

Example:

    input := bufio.NewScanner(os.Stdin)
    for input.Scan() {
        fmt.Println(input.Text() + "\n")
    }

    fmt.Fprintln(os.Stdout, "this is a message")
    fmt.Fprintln(os.Stderr, "this is an error")

## `strings`

### `strings.Join`

    func Join(a []string, sep string) string
        Join concatenates the elements of a to create a single string. The
        separator string sep is placed between elements in the resulting
        string.

Example:

    tokens := []string{"this", "is", "a", "test"}
    text := strings.Join(tokens, " ") // text == "this is a test"

### `strings.Split`

    func Split(s, sep string) []string
        Split slices s into all substrings separated by sep and returns a slice
        of the substrings between those separators.

        If s does not contain sep and sep is not empty, Split returns a slice
        of length 1 whose only element is s.

        If sep is empty, Split splits after each UTF-8 sequence. If both s and
        sep are empty, Split returns an empty slice.

        It is equivalent to SplitN with a count of -1.

Example:

    text := "this;is;a;test"
    tokens := strings.Split(text, ";")
